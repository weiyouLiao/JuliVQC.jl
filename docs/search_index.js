var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#**Getting-Started**","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To get started with JuliVQC.jl, you need to install both JuliVQC.jl and its dependency QuantumCircuits.jl. Note that these packages are not part of Julia's official package registry, so you need to install them directly from GitHub.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"gettingstarted/#Step-1:-Create-a-Dedicated-Julia-Environment-(Highly-Recommended)","page":"Getting Started","title":"Step 1: Create a Dedicated Julia Environment (Highly Recommended)","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"We strongly recommend creating a dedicated Julia environment for JuliVQC.jl to prevent dependency conflicts with other projects. Follow these steps:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Open the Julia REPL.\nNavigate to your project folder (or any desired directory).\nActivate a new environment:\npkg> activate .\nThis command creates and activates a new Julia environment in the current folder. A Project.toml file will be generated automatically.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"gettingstarted/#Step-2:-Install-QuantumCircuits.jl","page":"Getting Started","title":"Step 2: Install QuantumCircuits.jl","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"⚠️ Important: The required QuantumCircuits.jl package is a custom version different from the official Julia package of the same name. Follow the steps below to avoid conflicts.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Install the custom version of QuantumCircuits.jl from the correct GitHub repository using the following command:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"pkg> add https://github.com/weiyouLiao/QuantumCircuits.jl","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This ensures you're installing the required custom version and avoiding conflicts with the official package.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"gettingstarted/#Step-3:-Install-JuliVQC.jl","page":"Getting Started","title":"Step 3: Install JuliVQC.jl","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Once the correct version of QuantumCircuits.jl is installed, proceed to install JuliVQC.jl from its GitHub repository:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"pkg> add https://github.com/weiyouLiao/JuliVQC.jl","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"gettingstarted/#Step-4:-Verify-Installation","page":"Getting Started","title":"Step 4: Verify Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"After completing the above steps, verify the installation by loading JuliVQC.jl in the Julia REPL:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using JuliVQC","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If no errors occur, the installation was successful, and you're ready to start building variational quantum circuits!","category":"page"},{"location":"gettingstarted/#Quick-Start","page":"Getting Started","title":"Quick Start","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Here’s how you can get started with JuliVQC.jl:","category":"page"},{"location":"gettingstarted/#Example-1:-Create-a-Two-Qubit-Bell-State","page":"Getting Started","title":"Example 1: Create a Two-Qubit Bell State","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using JuliVQC\nusing QuantumCircuits\n\n# Create a 2-qubit quantum state\nstate = StateVector(2)\n\n# Define a quantum circuit\ncircuit = QCircuit()\npush!(circuit, HGate(1))         # Add a Hadamard gate on qubit 1\npush!(circuit, CNOTGate(1, 2))   # Add a CNOT gate between qubits 1 and 2\n\n# Apply the circuit to the quantum state\napply!(circuit, state)\n\n# Perform quantum measurement\ni, prob = measure!(state, 1)\nprintln(\"Probability of qubit 1 being in state $i is $prob.\")","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"gettingstarted/#Example-2:-Build-and-Optimize-a-Variational-Quantum-Circuit","page":"Getting Started","title":"Example 2: Build and Optimize a Variational Quantum Circuit","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Constructing a variational quantum circuit is just as easy:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using JuliVQC\nusing QuantumCircuits\nusing Zygote\n\nL = 3  # Number of qubits\nstate = StateVector(L)\n\n# Define a variational quantum circuit\ncircuit = QCircuit()\nfor i in 1:L\n    push!(circuit, RzGate(i, rand(), isparas=true))\n    push!(circuit, RyGate(i, rand(), isparas=true))\n    push!(circuit, RzGate(i, rand(), isparas=true))\nend\n\nfor depth in 1:2\n    for i in 1:L-1\n        push!(circuit, CNOTGate(i, i+1))\n    end\n    for i in 1:L\n        push!(circuit, RzGate(i, rand(), isparas=true))\n        push!(circuit, RxGate(i, rand(), isparas=true))\n        push!(circuit, RzGate(i, rand(), isparas=true))\n    end\nend\n\n# Define a target state\ntarget_state = StateVector([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0])\n\n# Define a loss function\nloss(c) = distance(target_state, c * state)\n\n# Compute the gradient of the loss function\nv = loss(circuit)\ngrad = gradient(loss, circuit)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section demonstrates how to use JuliVQC.jl to create variational quantum circuits (VQCs) and integrate them with Flux.jl for optimization tasks. Additionally, some utility functions provided by the library are introduced.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Creating-a-Variational-Quantum-Circuit","page":"Examples","title":"Creating a Variational Quantum Circuit","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A variational quantum circuit (VQC) is a parameterized quantum circuit composed of gates with tunable parameters. Below is an example of how to manually construct such a circuit.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using JuliVQC,QuantumCircuits\n\n# Circuit parameters\nL = 3         # Number of qubits\ndepth = 2     # Depth of the circuit\n\n# Create an empty quantum circuit\ncircuit = QCircuit()\n\n# Add parameterized gates to the circuit\nfor i in 1:L\n    push!(circuit, RzGate(i, rand(),isparas=true))# Rz rotation with random parameter\n\tpush!(circuit, RyGate(i, rand(),isparas=true))# Ry rotation with random parameter\n\tpush!(circuit, RzGate(i, rand(),isparas=true))# Rz rotation with random parameter\nend\n\n# Add entangling gates and repeat for each layer of depth\nfor l in 1:depth\n    for i in 1:L-1\n        push!(circuit, CNOTGate((i, i+1)))       # Add CNOT gate\n    end\n    for i in 1:L\n\t\tpush!(circuit, RzGate(i, rand(),isparas=true))\n\t\tpush!(circuit, RxGate(i, rand(),isparas=true))\n\t\tpush!(circuit, RzGate(i, rand(),isparas=true))\n    end\nend\n\n# Extract all the parameters of the circuit\nparas = parameters(circuit)\n\n# Reset all the parameters of the circuit to zeros\nnew_paras = zeros(length(paras))\nset_parameters!(new_paras, circuit)\nparas = parameters(circuit)  # Updated parameters\n\n# Compute the gradient of a loss function with respect to the circuit parameters\nusing Zygote\ntarget_state = StateVector([.0,.0,.0,.0,.0,.0,.1,.0])        # Random target quantum state\ninitial_state = StateVector(3)       # Initial quantum state\nloss(c) = distance(target_state, c * initial_state)  # Define the loss function\ngrad = gradient(loss, circuit)  # Compute the gradient","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The above process of creating a VQC has already been encapsulated into the following convenient function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"variational_circuit(L::Int, depth::Int, g::Function=rand)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For example, you can directly create a VQC by calling:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"circuit = variational_circuit(3, 2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#A-Simple-Application-of-JuliVQC-and-Flux","page":"Examples","title":"A Simple Application of JuliVQC and Flux","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates how to integrate a variational quantum circuit  with Flux.jl, a machine learning library for Julia. The task is to optimize the parameters of a VQC to prepare a target quantum state.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using VQC\nusing Zygote\nusing Flux.Optimise\n\n# Create a variational quantum circuit\ncircuit = variational_circuit(3, 2)\n\n# Define the target state and initial state\ntarget_state = StateVector([.0,.0,.0,.0,.0,.0,.1,.0])  # Target quantum state\ninitial_state = StateVector(3)                                 # Initial quantum state\n\n# Define the loss function: distance between target and evolved state\nloss(c) = distance(target_state, c * initial_state)\n\n# Initialize the optimizer\nopt = ADAM()\n\n# Number of training epochs\nepochs = 10\n\n# Extract initial parameters\nx0 = parameters(circuit)\n\n# Optimization loop\nfor i in 1:epochs\n    # Compute the gradient of the loss with respect to the circuit parameters\n    grad = collect_variables(gradient(loss, circuit))\n    \n    # Update the parameters using the optimizer\n    Optimise.update!(opt, x0, grad)\n    set_parameters!(x0, circuit)  # Update circuit parameters\n    \n    # Print the loss value for each epoch\n    println(\"Loss value at iteration $i: $(loss(circuit))\")\nend","category":"page"},{"location":"examples/#Explanation-of-the-Workflow","page":"Examples","title":"Explanation of the Workflow","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Circuit Initialization: A variational quantum circuit (variational_circuit) is initialized with random parameters.\nTarget and Initial States: The target state and initial state are defined. The circuit's goal is to transform the initial state into the target state.\nLoss Function: The loss function quantifies the \"distance\" between the target state and the circuit-evolved state.\nOptimization: Using Flux's ADAM optimizer, the circuit parameters are iteratively updated to minimize the loss.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Utility-Functions","page":"Examples","title":"Utility Functions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following utility functions are provided by JuliVQC.jl to facilitate working with quantum circuits:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"collect_variables(args...)           # Collect all variables (parameters) from the circuit\nparameters(args...)                  # Get the parameters of the circuit\nset_parameters!(coeff::AbstractVector{<:Number}, args...)  # Set parameters of the circuit\nsimple_gradient(f, args...; dt::Real=1.0e-6)               # Compute numerical gradients\ncheck_gradient(f, args...; dt::Real=1.0e-6, atol::Real=1.0e-4, verbose::Int=0)  \n# Verify the correctness of gradients","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These functions simplify common operations, such as extracting or modifying circuit parameters and computing gradients, making the library more user-friendly.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In this section we show the working pipeline of JuliVQC for simulating quantum circuits and variational quantum circuits, as well as their noisy counterparts.","category":"page"},{"location":"manual/#Initialize-a-quantum-state","page":"Manual","title":"Initialize a quantum state","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The first step of using JuliVQC for any quantum circuit simulation is to initialize a quantum state stored as a state vector. JuliVQC provides twos function: StateVector and DensityMatrix to initialize a pure state and a mixed state respectively. Mathematically, the data of an n-qubit pure state should be understood as a rank-n tensor, and the data of an n-qubit mixed state should be understood as a rank-2n tensor, where each dimension has size 2. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As implementation-wise details, the qubits are internally labeled from 1 to n for pure state , while for mixed state the ket indices are labeled from 1 to n and the bra indices are labeled from n+1 to 2n. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Column-major storage is used for the data of both pure and mixed quantum states, e.g., the smaller indices of the tensor are iterated first. These details are not important for the users if they do not want to access the raw data of the quantum states.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuliVQC,QuantumCircuits\n\nstate = StateVector(2)\nn = 2\npure_state = StateVector(n)\nmixed_state = DensityMatrix(n)\ncustom_pure_state= StateVector([.0,.1,.0,.0])\ncustom_mixed_state = DensityMatrix([.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.1])","category":"page"},{"location":"manual/#Quantum-gates","page":"Manual","title":"Quantum gates","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The second step of using JuliVQC is to build a quantum circuit, for which one needs to define each elementary quantum gate operations (and quantum channels for noisy quantum circuits). ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The universal way of defining quantum gates is to use the function QuantumGate(positions, data), where the first argument specifies the qubits indices that the gate operates on, for example positions =(1, 3), and the second argument is the raw data of the gate operation which should be a unitary matrix. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In the meantime, JuliVQC provides specialized definitions of commonly used quantum gates \"X, Y, Z, S, H, sqrtX, sqrtY, T, Rx, Ry,Rz, CONTROL, CZ, CNOT, CX,SWAP, iSWAP, XGate, YGate, ZGate, HGate, SGate, TGate, SqrtXGate, SqrtYGate, RxGate, RyGate, RzGate, CZGate, CNOTGate, SWAPGate, iSWAPGate, CRxGate, CRyGate, CRzGate, TOFFOLIGate\". Specific optimizations have been implemented for most of the predefined gate operations by exploring their structures, which will usually be faster than using the QuantumGate} function.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"JuliVQC also provides general two-qubit and three-qubit controlled gate operations: CONTROLGate and CONTROLCONTROLGate, which can be used as CONTROLGate(i,j,data) (i is the control qubit and j is the target qubit) and CONTROLCONTROLGate(i,j,k,data) (i and j are control qubits and k is the target qubit), with data the raw data for the target single-qubit operation. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The general interface for initializing a parametric quantum gate is G(i..., paras; isparas) where paras is a single scalar if G only has a single parameter or an array of scalars if G has several parameters.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The illustrative code for initializing non-parametric and parametric quantum gates:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuliVQC,QuantumCircuits\nn=1\nX = XGate(n)\nncontrol = 1\nntarget = 2\nCNOT = CNOTGate(ncontrol, ntarget)\ntheta = pi/2\nnon_para_Rx = RxGate(n, theta, isparas=false) # a non-parametric Rx gate\npara_Rx = RxGate(n, theta, isparas=true) # a parametric Rx gate","category":"page"},{"location":"manual/#Noise-channels","page":"Manual","title":"Noise channels","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In additional to the quantum gate operations, an indispensable ingredient for noisy quantum circuit is the quantum channel, which describes the effects of noises. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Similar to the function QuantumGate, JuliVQC provides a universal function QuantumMap(positions, kraus) which allows the user to define arbitrary quantum channels, where the first argument positions specifies the qubit indices that the quantum channel operates on, similar to the case of a unitary quantum gate, and the second argument kraus is a list of Kraus operators.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"JuliVQC also provides some commonly used single-qubit quantum channels based on the function QuantumMap, including AmplitudeDamping(pos, p) ,PhaseDamping(pos, p),Depolarizing(pos, p)","category":"page"},{"location":"manual/#Manipulating-and-running-quantum-circuits","page":"Manual","title":"Manipulating and running quantum circuits","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"JuliVQC uses a very simple wrapper QCircuit on top of an array of quantum operations to represent a quantum circuit. Each element of QCircuit can be either a (parametric) unitary gate operation, a quantum channel, or a QCircuit. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"After manipulating the quantum circuit, one could apply the quantum circuit onto the quantum state using theapply!(circ, state) function. state can either be a pure state or a density matrix, which modifies the quantum state in-place. There is also an out-of-place version of this operation, e.g., apply(circ, state) or equivalently circ * state, which will return a new quantum state and is useful for running variational quantum algorithms. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuliVQC\n\nstate = StateVector(2)\ncircuit = QCircuit([HGate(1), RyGate(1,pi/4,isparas = false) ,CNOTGate(1,2)])\napply!(circuit,state)\noutcome, prob = measure!(state,2)","category":"page"},{"location":"manual/#Qubit-operators","page":"Manual","title":"Qubit operators","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The qubit operator is represented as a QubitsOperator object in JuliVQC, which can be built as in following example. Once a qubit operator op has been initialized, one could apply the function expectation(op, state) to evaluate the expectation of it on the quantum state state.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuliVQC\n\nfunction heisenberg_1d(L; hz=1, J=1)\n    terms = []\n      # one site terms\n    for i in 1:L\n        push!(terms, QubitsTerm(i=>\"z\", coeff=hz))\n    end\n    # nearest-neighbour interactions\n    for i in 1:L-1\n        push!(terms, QubitsTerm(i=>\"x\", i+1=>\"x\", coeff=J))\n        push!(terms, QubitsTerm(i=>\"y\", i+1=>\"y\", coeff=J))\n        push!(terms, QubitsTerm(i=>\"z\", i+1=>\"z\", coeff=J))\n    end\n    return QubitsOperator(terms)\nend","category":"page"},{"location":"manual/#Automatic-differentiation","page":"Manual","title":"Automatic differentiation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"JuliVQC has a transparent support for automatic differentiation, one could simply run a variational quantum algorithm in the similar way as a standard quantum algorithm. The major difference from running a standard quantum algorithm is that one wraps the expectation function into a loss function, and then use the function gradient(loss, circ) to obtain the gradient of the parameters within the quantum circuit. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuliVQC, Zygote\nstate = StateVector(3)\nop = heisenberg_1d(3) #Construct Heisenberg Hamiltonian as a qubit operator\nalpha = 0.01\ncirc = QCircuit()\nfor depth in 1:4\n    for i in 1:2\n        push!(circ,CNOTGate(i,i+1))\n    end\n    for i in 1:3\n        push!(circ,RyGate(i,randn(),isparas=true))\n        push!(circ,RxGate(i,randn(),isparas=true))\n    end     \nend\n\nloss(circ)=real(expectation(op, circ * state))\ngrad = gradient(loss, circ)[1] # calculate gradient\nparas = active_parameters(circ) # extracting the parameters\nnew_paras = paras - alpha * grad # gradient descent to update parameters\nreset_parameters!(circ, new_paras) # reset parameters","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Under the hood, the gradient is calculated using the Zygote auto-differentiation framework, by rewriting the backpropagation rules of a few elementary operations (the detailed algorithm we use to implement the classical backpropagation  can be found in our paper (https://arxiv.org/abs/2406.19212).","category":"page"},{"location":"#JuliVQC.jl's-documentation","page":"Home","title":"JuliVQC.jl's documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuliVQC.jl is a high-performance Julia library designed for variational quantum circuit (VQC) simulations. Its mission is to provide seamless support for automatic differentiation while enabling users to easily build hybrid quantum-classical algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core philosophy of JuliVQC.jl revolves around three principles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transparent implementation: Built using Julia, a high-performance and dynamic programming language.\nEfficiency-focused: Cache-friendly elementary operations with shared-memory parallelization.\nNative automatic differentiation: Supports both noiseless and noisy quantum circuits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Start to use JuliVQC.jl from \"Getting Started\" section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"gettingstarted.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"examples.md\"]\nDepth = 2","category":"page"}]
}
