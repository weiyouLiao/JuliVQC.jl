<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · JuliVQC.jl</title><meta name="title" content="Manual · JuliVQC.jl"/><meta property="og:title" content="Manual · JuliVQC.jl"/><meta property="twitter:title" content="Manual · JuliVQC.jl"/><meta name="description" content="Documentation for JuliVQC.jl."/><meta property="og:description" content="Documentation for JuliVQC.jl."/><meta property="twitter:description" content="Documentation for JuliVQC.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="JuliVQC.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">JuliVQC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Initialize-a-quantum-state"><span>Initialize a quantum state</span></a></li><li><a class="tocitem" href="#Quantum-gates"><span>Quantum gates</span></a></li><li><a class="tocitem" href="#Noise-channels"><span>Noise channels</span></a></li><li><a class="tocitem" href="#Manipulating-and-running-quantum-circuits"><span>Manipulating and running quantum circuits</span></a></li><li><a class="tocitem" href="#Qubit-operators"><span>Qubit operators</span></a></li><li><a class="tocitem" href="#Automatic-differentiation"><span>Automatic differentiation</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/weiyouLiao/JuliVQC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/weiyouLiao/JuliVQC.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>In this section we show the working pipeline of JuliVQC for simulating quantum circuits and variational quantum circuits, as well as their noisy counterparts.</p><h2 id="Initialize-a-quantum-state"><a class="docs-heading-anchor" href="#Initialize-a-quantum-state">Initialize a quantum state</a><a id="Initialize-a-quantum-state-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-a-quantum-state" title="Permalink"></a></h2><p>The first step of using JuliVQC for any quantum circuit simulation is to initialize a quantum state stored as a state vector. JuliVQC provides twos function: <code>StateVector</code> and <code>DensityMatrix</code> to initialize a pure state and a mixed state respectively. Mathematically, the data of an <span>$n$</span>-qubit pure state should be understood as a rank-<span>$n$</span> tensor, and the data of an <span>$n$</span>-qubit mixed state should be understood as a rank-<span>$2n$</span> tensor, where each dimension has size <span>$2$</span>. </p><p>As implementation-wise details, the qubits are internally labeled from <span>$1$</span> to <span>$n$</span> for pure state , while for mixed state the ket indices are labeled from <span>$1$</span> to <span>$n$</span> and the bra indices are labeled from <span>$n+1$</span> to <span>$2n$</span>. </p><p>Column-major storage is used for the data of both pure and mixed quantum states, e.g., the smaller indices of the tensor are iterated first. These details are not important for the users if they do not want to access the raw data of the quantum states.</p><pre><code class="language-julia hljs">using JuliVQC,QuantumCircuits

state = StateVector(2)
n = 2
pure_state = StateVector(n)
mixed_state = DensityMatrix(n)
custom_pure_state= StateVector([.0,.1,.0,.0])
custom_mixed_state = DensityMatrix([.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.0,.1])</code></pre><h2 id="Quantum-gates"><a class="docs-heading-anchor" href="#Quantum-gates">Quantum gates</a><a id="Quantum-gates-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-gates" title="Permalink"></a></h2><p>The second step of using JuliVQC is to build a quantum circuit, for which one needs to define each elementary quantum gate operations (and quantum channels for noisy quantum circuits). </p><p>The universal way of defining quantum gates is to use the function <code>QuantumGate(positions, data)</code>, where the first argument specifies the qubits indices that the gate operates on, for example <code>positions =(1, 3)</code>, and the second argument is the raw data of the gate operation which should be a unitary matrix. </p><p>In the meantime, JuliVQC provides specialized definitions of commonly used quantum gates &quot;<code>X</code>, <code>Y</code>, <code>Z</code>, <code>S</code>, <code>H</code>, <code>sqrtX</code>, <code>sqrtY</code>, <code>T</code>, <code>Rx</code>, <code>Ry</code>,<code>Rz</code>, <code>CONTROL</code>, <code>CZ</code>, <code>CNOT</code>, <code>CX</code>,<code>SWAP</code>, <code>iSWAP</code>, <code>XGate</code>, <code>YGate</code>, <code>ZGate</code>, <code>HGate</code>, <code>SGate</code>, <code>TGate</code>, <code>SqrtXGate</code>, <code>SqrtYGate</code>, <code>RxGate</code>, <code>RyGate</code>, <code>RzGate</code>, <code>CZGate</code>, <code>CNOTGate</code>, <code>SWAPGate</code>, <code>iSWAPGate</code>, <code>CRxGate</code>, <code>CRyGate</code>, <code>CRzGate</code>, <code>TOFFOLIGate</code>&quot;. Specific optimizations have been implemented for most of the predefined gate operations by exploring their structures, which will usually be faster than using the <code>QuantumGate}</code> function.</p><p>JuliVQC also provides general two-qubit and three-qubit controlled gate operations: <code>CONTROLGate</code> and <code>CONTROLCONTROLGate</code>, which can be used as <code>CONTROLGate(i,j,data)</code> (<code>i</code> is the control qubit and <code>j</code> is the target qubit) and <code>CONTROLCONTROLGate(i,j,k,data)</code> (<code>i</code> and <code>j</code> are control qubits and <code>k</code> is the target qubit), with <code>data</code> the raw data for the target single-qubit operation. </p><p>The general interface for initializing a parametric quantum gate is <code>G(i..., paras; isparas)</code> where <code>paras</code> is a single scalar if <code>G</code> only has a single parameter or an array of scalars if <code>G</code> has several parameters.</p><p>The illustrative code for initializing non-parametric and parametric quantum gates:</p><pre><code class="language-julia hljs">using JuliVQC,QuantumCircuits
n=1
X = XGate(n)
ncontrol = 1
ntarget = 2
CNOT = CNOTGate(ncontrol, ntarget)
theta = pi/2
non_para_Rx = RxGate(n, theta, isparas=false) # a non-parametric Rx gate
para_Rx = RxGate(n, theta, isparas=true) # a parametric Rx gate</code></pre><h2 id="Noise-channels"><a class="docs-heading-anchor" href="#Noise-channels">Noise channels</a><a id="Noise-channels-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-channels" title="Permalink"></a></h2><p>In additional to the quantum gate operations, an indispensable ingredient for noisy quantum circuit is the quantum channel, which describes the effects of noises. </p><p>Similar to the function <code>QuantumGate</code>, JuliVQC provides a universal function <code>QuantumMap(positions, kraus)</code> which allows the user to define arbitrary quantum channels, where the first argument <code>positions</code> specifies the qubit indices that the quantum channel operates on, similar to the case of a unitary quantum gate, and the second argument <code>kraus</code> is a list of Kraus operators.</p><p>JuliVQC also provides some commonly used single-qubit quantum channels based on the function <code>QuantumMap</code>, including <code>AmplitudeDamping(pos, p)</code> ,<code>PhaseDamping(pos, p)</code>,Depolarizing<code>(pos, p)</code></p><h2 id="Manipulating-and-running-quantum-circuits"><a class="docs-heading-anchor" href="#Manipulating-and-running-quantum-circuits">Manipulating and running quantum circuits</a><a id="Manipulating-and-running-quantum-circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-and-running-quantum-circuits" title="Permalink"></a></h2><p>JuliVQC uses a very simple wrapper <code>QCircuit</code> on top of an array of quantum operations to represent a quantum circuit. Each element of <code>QCircuit</code> can be either a (parametric) unitary gate operation, a quantum channel, or a <code>QCircuit</code>. </p><p>After manipulating the quantum circuit, one could apply the quantum circuit onto the quantum state using the<code>apply!(circ, state)</code> function. <code>state</code> can either be a pure state or a density matrix, which modifies the quantum state in-place. There is also an out-of-place version of this operation, e.g., <code>apply(circ, state)</code> or equivalently <code>circ * state</code>, which will return a new quantum state and is useful for running variational quantum algorithms. </p><pre><code class="language-julia hljs">using JuliVQC

state = StateVector(2)
circuit = QCircuit([HGate(1), RyGate(1,pi/4,isparas = false) ,CNOTGate(1,2)])
apply!(circuit,state)
outcome, prob = measure!(state,2)</code></pre><h2 id="Qubit-operators"><a class="docs-heading-anchor" href="#Qubit-operators">Qubit operators</a><a id="Qubit-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Qubit-operators" title="Permalink"></a></h2><p>The qubit operator is represented as a <code>QubitsOperator</code> object in JuliVQC, which can be built as in following example. Once a qubit operator <code>op</code> has been initialized, one could apply the function <code>expectation(op, state)</code> to evaluate the expectation of it on the quantum state <code>state</code>.</p><pre><code class="language-julia hljs">using JuliVQC

function heisenberg_1d(L; hz=1, J=1)
    terms = []
      # one site terms
    for i in 1:L
        push!(terms, QubitsTerm(i=&gt;&quot;z&quot;, coeff=hz))
    end
    # nearest-neighbour interactions
    for i in 1:L-1
        push!(terms, QubitsTerm(i=&gt;&quot;x&quot;, i+1=&gt;&quot;x&quot;, coeff=J))
        push!(terms, QubitsTerm(i=&gt;&quot;y&quot;, i+1=&gt;&quot;y&quot;, coeff=J))
        push!(terms, QubitsTerm(i=&gt;&quot;z&quot;, i+1=&gt;&quot;z&quot;, coeff=J))
    end
    return QubitsOperator(terms)
end</code></pre><h2 id="Automatic-differentiation"><a class="docs-heading-anchor" href="#Automatic-differentiation">Automatic differentiation</a><a id="Automatic-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation" title="Permalink"></a></h2><p>JuliVQC has a transparent support for automatic differentiation, one could simply run a variational quantum algorithm in the similar way as a standard quantum algorithm. The major difference from running a standard quantum algorithm is that one wraps the <code>expectation</code> function into a loss function, and then use the function <code>gradient(loss, circ)</code> to obtain the gradient of the parameters within the quantum circuit. </p><pre><code class="language-julia hljs">using JuliVQC, Zygote
state = StateVector(3)
op = heisenberg_1d(3) #Construct Heisenberg Hamiltonian as a qubit operator
alpha = 0.01
circ = QCircuit()
for depth in 1:4
    for i in 1:2
        push!(circ,CNOTGate(i,i+1))
    end
    for i in 1:3
        push!(circ,RyGate(i,randn(),isparas=true))
        push!(circ,RxGate(i,randn(),isparas=true))
    end     
end

loss(circ)=real(expectation(op, circ * state))
grad = gradient(loss, circ)[1] # calculate gradient
paras = active_parameters(circ) # extracting the parameters
new_paras = paras - alpha * grad # gradient descent to update parameters
reset_parameters!(circ, new_paras) # reset parameters</code></pre><p>Under the hood, the gradient is calculated using the Zygote auto-differentiation framework, by rewriting the backpropagation rules of a few elementary operations (the detailed algorithm we use to implement the classical backpropagation  can be found in our paper (https://arxiv.org/abs/2406.19212).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gettingstarted/">« Getting Started</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 24 December 2024 09:08">Tuesday 24 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
